<#
/*
T4EmbeddedResources Version 1.0.0

T4EmbeddedResources creates unmanaged stream providers for embedded resources in a RELEASE build while using the
resource from disk in a DEBUG build. This is to allow for resources to be editted while an application is running/being 
developed without requiring a rebuild for each change.

Settings code has been harvested from T4MVC MvcSettings (https://github.com/T4MVC/T4MVC) [Licence: Apache 2.0]
*/
#>
<#@ template language="C#" hostSpecific="true" debug="True" #>
<#@ output extension="generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ assembly name="EnvDte" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#
    var model = GetEmbeddedProjectItems(this, Host);
    var manager = Manager.Create(Host, GenerationEnvironment);
#>
<# manager.StartHeader(); #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by <#= model.TemplateFileName #> at <#= DateTime.Now #>.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//		Note: 
//			If a resource is not being added, ensure the the build action has
//			been set to "Embedded Resource".
// </auto-generated>
//------------------------------------------------------------------------------
<# manager.EndBlock(); #>
#if DEBUG
using System.Diagnostics;
#endif
using System.IO;

namespace <#= model.Namespace #>
{
    /// <summary>
    /// Collection of resource providers to retrieve a embedded resources. Resources are retrieved from disk 
    /// in a DEBUG build by reconstructing the path to the resource by searching for the .sln file in the 
    /// parent tree structure.
    /// </summary>
    public static class <#= model.ClassName #>
    {
        static <#= model.ClassName #>() 
        {
#if DEBUG
<# foreach (var i in model.EmbeddedResources) { #>
            <#= i.PropertyName #> = new DebugResourceStreamProvider(@"<#= i.SlnRelativePath #>", @"<#= i.ResourceName #>");
<# } #>
#else
<# foreach (var i in model.EmbeddedResources) { #>
            <#= i.PropertyName #> = new EmbeddedResourceStreamProvider(@"<#= i.ResourceName #>");
<# } #>
#endif
        }

<# foreach (var i in model.EmbeddedResources) { #>
        public static <#= model.ResourceStreamProviderBase #> <#= i.PropertyName #> { get; }
<# } #>

#if DEBUG
       /// <summary>
       /// Resource provider to provide an unmanaged stream to an embedded resource from disk. 
       /// This is for development use only with release builds using <see cref="EmbeddedResourceStreamProvider" />.
       /// <summary>
       public class DebugResourceStreamProvider : <#= model.ResourceStreamProviderBase #>
       {
            static string _slnPath;
            readonly string _path;

            bool _embeddedResourceFound;

            static DebugResourceStreamProvider()
            {
                var assmeblyPath = Path.GetDirectoryName(typeof(DebugResourceStreamProvider).Assembly.Location);
                var root = new DirectoryInfo(assmeblyPath);
                while (root != null)
                {
                    if (File.Exists(Path.Combine(root.FullName, @"<#= model.Solution.FileName #>")))
                    {
                        _slnPath = root.FullName;
                        return;
                    }

                    root = root.Parent;
                }

                Debug.Write($"{typeof(DebugResourceStreamProvider).FullName}: Unable to find .sln root (<#= model.Solution.FileName #>).");
            }

            internal DebugResourceStreamProvider(string path, string resourceName)
            {
                _embeddedResourceFound = false;

                _path = Path.Combine(_slnPath, path);
                ResourceName = resourceName;
            }

            /// <summary>
            /// Gets an unmanaged stream for an embedded resource from disk.
            /// </summary>
            public Stream GetTemplateStream()
            {
                AssertEmbeddedResourceCanBeFound();
                Debug.Assert(File.Exists(_path), $"Unable to find file on disk [{_path}]");

                Trace.Write($"{typeof(DebugResourceStreamProvider).FullName}: Reading {ResourceName} from {_path}.");

                return File.OpenRead(_path);
            }

            /// <summary>
            /// Asserts that the resource exists as an embedded resource (safety check for a release build).
            /// </summary>
            private void AssertEmbeddedResourceCanBeFound()
            {
                if (_embeddedResourceFound)
                {
                    return;
                }

                var assembly = typeof(EmbeddedResourceStreamProvider).Assembly;
                var resourceInfo = assembly.GetManifestResourceInfo(ResourceName);

                Debug.Assert(resourceInfo != null, $"Unable to find resource [{ResourceName}]");

                _embeddedResourceFound = true;
            }

            /// <summary>
            /// Associated embedded resource name.
            /// </summary>
            public string ResourceName { get; }
       }
#endif

       /// <summary>
       /// Creates an unamanged stream for an embedded resource.
       /// </summary>
       public class EmbeddedResourceStreamProvider : <#= model.ResourceStreamProviderBase #>
       {
            internal EmbeddedResourceStreamProvider(string resourceName)
            {
                ResourceName = resourceName;
            }

            /// <summary>
            /// Resource name.
            /// </summary>
            public string ResourceName { get; }

            /// <summary>
            /// Gets an unmanaged stream for an embedded resource.
            /// </summary>
            public Stream GetTemplateStream()
            {
                var assembly = typeof(EmbeddedResourceStreamProvider).Assembly;
                return assembly.GetManifestResourceStream(ResourceName);
            }
       }
    }
<# if (model.IncludeResourceStreamProviderInterface) { #>

    /// <summary>
    /// Resource stream provider.
    /// </summary>
    public interface IResourceStreamProvider
    {
        /// <summary>
        /// Gets an unmanaged stream for a resource.
        /// </summary>
        Stream GetTemplateStream();
    }
<# } #>
}
<#
    settings.SaveChanges(manager); 
#>
<#+
    static TextTransformation TT;
    static string T4FileName;
    static Settings settings;

    public Model GetEmbeddedProjectItems(TextTransformation tt, ITextTemplatingEngineHost host)
    {
        TT = tt;
        T4FileName = Path.GetFileName(host.TemplateFile);
        settings = Settings.Load(Host);

        var visualStudio = (this.Host as IServiceProvider).GetService(typeof(DTE)) as DTE;
        var solution = visualStudio.Solution;
        var templateProjectItem = solution.FindProjectItem(T4FileName);
        var project = templateProjectItem.ContainingProject as Project;

        ProjectItems projectItemsRoot = GetTemplateParentProjectItems(templateProjectItem);

        if (string.IsNullOrWhiteSpace(settings.Namespace))
        {
            if (!IsValidName(settings.Namespace, true))
            {
                throw new ApplicationException(string.Format("'{0}' is not a valid namespace.", settings.Namespace));
            }
            
            settings.Namespace = project.Properties.Item("DefaultNamespace").Value.ToString();
        }

        if (!IsValidName(settings.ClassName, false))
        {
            throw new ApplicationException(string.Format("'{0}' is not a valid class name.", settings.ClassName));
        }

        if (!string.IsNullOrWhiteSpace(settings.ResourceStreamProviderBase) && !IsValidName(settings.ResourceStreamProviderBase, true))
        {
            throw new ApplicationException(string.Format("'{0}' is not a valid base class name.", settings.ResourceStreamProviderBase));
        }

        return new Model(settings.Namespace, settings.ClassName, settings.ResourceStreamProviderBase, Host.TemplateFile, solution, project, FindEmbeddedResources(projectItemsRoot));
    }

    bool IsValidName(string value, bool allowParts) 
    {
        var parts = allowParts ? value.Split(new[] {'.'}) : new [] { value };

        foreach (var part in parts)
        {
            if (!CodeGenerator.IsValidLanguageIndependentIdentifier(value))
            {
                return false;
            }            
        }

        return true;
    }

    ProjectItems GetTemplateParentProjectItems(ProjectItem templateProjectItem)
    {
        var hostParent = templateProjectItem
                                .Collection
                                .Parent;

        var hostParentProjectItem = hostParent as ProjectItem;
        if (hostParentProjectItem != null)
        {
            return hostParentProjectItem.ProjectItems;
        }
        
        var hostParentProject = hostParent as Project;
        if (hostParentProject != null)
        {
            return hostParentProject.ProjectItems;
        }

        throw new ApplicationException("Unable to determine template parent.");
    }

    IEnumerable<ProjectItem> FindEmbeddedResources(EnvDTE.ProjectItems items)
    {
        foreach(EnvDTE.ProjectItem item in items)
        {
            if (item.ProjectItems.Count > 0)
            {
                continue;
            }
     
            var prop = item.Properties.Item("BuildAction");
            if (prop != null 
                && (VSLangProj.prjBuildAction)prop.Value == VSLangProj.prjBuildAction.prjBuildActionEmbeddedResource)
            {
                yield return item;
            }
        }
    }

    public class Model
    {
        public Model(string @namespace, string className, string resourceStreamProviderBase, string templatePath, EnvDTE.Solution solution, EnvDTE.Project project, IEnumerable<ProjectItem> resources)
        {
            Namespace = @namespace;
            ClassName =  className;
            IncludeResourceStreamProviderInterface = string.IsNullOrWhiteSpace(resourceStreamProviderBase);
            ResourceStreamProviderBase = string.IsNullOrWhiteSpace(resourceStreamProviderBase)
                                         ? "IResourceStreamProvider"
                                         : resourceStreamProviderBase;

            TemplateFileName = Path.GetFileName(templatePath);
            Solution = new SolutionModel(solution);
            Project = new ProjectModel(project);
            EmbeddedResources = resources.Select(x => new ResourceModel(Solution, Project, x)).ToList();
        }

        public string ClassName { get; }

        public bool IncludeResourceStreamProviderInterface { get; }

        public IEnumerable<ResourceModel> EmbeddedResources { get; }

        public string Namespace { get; }

        public ProjectModel Project { get; }
  
        public string ResourceStreamProviderBase { get; }
        
        public SolutionModel Solution { get; }
  
        public string TemplateFileName { get; }
  
        public class SolutionModel
        {
            public SolutionModel(EnvDTE.Solution solution)
            {
                FileName = System.IO.Path.GetFileName(solution.FullName);
                Path = System.IO.Path.GetDirectoryName(solution.FullName);
            }

            public string FileName { get; }

            public string Path { get; }
        }
  
        public class ProjectModel
        {
            public ProjectModel(EnvDTE.Project project)
            {
                FileName = System.IO.Path.GetFileName(project.FullName);
                Path = System.IO.Path.GetDirectoryName(project.FullName);
                RootNamespace = project.Properties.Item("DefaultNamespace").Value.ToString();
            }
  
            public string FileName { get; }
            
            public string Path { get; }
  
            public string RootNamespace { get; }
        }
  
        public class ResourceModel
        {
            public ResourceModel(SolutionModel solution, ProjectModel project, ProjectItem resource)
            {
                SlnRelativePath = Uri.UnescapeDataString(GetRelativePath(PathWithTrailingSlash(solution.Path), (resource.FileNames[1])))
                                     .Replace("/", "\\");

                PropertyName = Regex.Replace(Path.GetFileNameWithoutExtension(resource.Name), @"[^\w\d]", "_");

                //todo: split resource path and name
                var relativeProjectPath = GetRelativePath(PathWithTrailingSlash(project.Path), resource.FileNames[1]);
                var rawResourceName = string.Concat(project.RootNamespace, ".", Uri.UnescapeDataString(relativeProjectPath))
                                    .Replace("/", ".");
                ResourceName = Regex.Replace(rawResourceName, @"[^\w\d\.]", "_");
            }

            string PathWithTrailingSlash(string path)
            {
                return path.EndsWith("\\")
                            ? path
                            : string.Concat(path, "\\");
            }

            public string SlnRelativePath { get; }
                 
            public string PropertyName { get; }
  
            public string ResourceName { get; }
  
            string GetRelativePath(string path1, string path2)
            {
                var p1 = new Uri(path1);
                var p2 = new Uri(path2);
                return p1.MakeRelativeUri(p2).OriginalString;
            }
        }
    }

/*
    Settings shamelessly copied from T4MVC (MvcSettings): https://github.com/T4MVC
*/

    class Settings : XmlSettings
    {
        public static Settings Load(ITextTemplatingEngineHost host)
        {
            return Load<Settings>(host);
        }

        public Settings()
        {
            Namespace = string.Empty;
            ClassName = "Resources";
            ResourceStreamProviderBase = string.Empty;
        }

        [System.ComponentModel.Description("Namespace to use.")]
        public string Namespace { get; set; }

        [System.ComponentModel.Description("Name to use for the containing class.")]
        public string ClassName { get; set; }

        [System.ComponentModel.Description("Full name of interface exposing \"Stream GetTemplateStream()\" method. If empty, IStreamResourceProvider will be added.")]
        public string ResourceStreamProviderBase { get; set; }
    }

/*
    XmlSettings base classes, if you need to modify the T4MVC properties edit the Settings Class Above
*/

    /// Base XmlSettings class, responsible for reading/writing the settigns file contents, all settings other 
    /// than string convertable types should decend from this class
    abstract class XmlSettingsBase
    {
        protected XmlSettingsBase()
        {
            this.NeedsSave = true;
        }

        protected virtual void Init()
        {
        }

        protected bool SaveAsChild { get; private set; }

        protected bool NeedsSave { get; private set; }

        protected static void SetSaveAsChild(XmlSettingsBase settings, bool value)
        {
            settings.SaveAsChild = value;
        }

        protected static void SetNeedsSave(XmlSettingsBase settings, bool value)
        {
            settings.NeedsSave = value;
        }

        protected static void WriteCommentedProperty(System.Xml.XmlWriter writer, string name)
        {
            writer.WriteComment(string.Concat("<", name, "></", name, ">"));
        }

        protected static void WritePropertyDesc(System.Xml.XmlWriter writer, System.ComponentModel.PropertyDescriptor property)
        {
            var desc = property.Attributes.OfType<System.ComponentModel.DescriptionAttribute>().FirstOrDefault();
            if(desc != null)
            {
                writer.WriteComment(desc.Description);
            }
        }

        protected virtual void Load(System.Xml.Linq.XElement xml)
        {
            this.NeedsSave = false;
            int matched = 0;
            int read = 0;
            foreach(System.ComponentModel.PropertyDescriptor property in System.ComponentModel.TypeDescriptor.GetProperties(this))
            {
                object pvalue;
                if(typeof(XmlSettingsBase).IsAssignableFrom(property.PropertyType) || (((pvalue = property.GetValue(this)) != null) && typeof(XmlSettingsBase).IsAssignableFrom(pvalue.GetType())))
                {
                    read++;
                    var value = xml.Element(property.Name);
                    if(value != null)
                    {
                        var settings = (XmlSettingsBase)property.GetValue(this);
                        settings.Load(value);
                        if(!settings.NeedsSave)
                            matched++;
                        settings.SaveAsChild = true;
                    }
                }
                else if(!property.IsReadOnly)
                {
                    read++;
                    var value = xml.Element(property.Name);
                    if(value != null)
                    {
                        if(property.Converter.CanConvertFrom(typeof(string)))
                        {
                            matched++;
                            property.SetValue(this, property.Converter.ConvertFromString(value.Value));
                        }
                        else
                        {
                            System.Reflection.MethodBase parser = property.PropertyType.GetMethod("Parse", new Type[] { typeof(string) });
                            if(parser == null)
                                parser = property.PropertyType.GetConstructor(new Type[] { typeof(string) });

                            if(parser != null)
                            {
                                matched++;
                                property.SetValue(this, parser.Invoke(null, new Object[] { value.Value }));
                            }
                        }
                    }
                }
            }
            this.NeedsSave = this.NeedsSave || (matched < read);
        }

        protected virtual void Save(System.Xml.XmlWriter writer)
        {
            foreach(System.ComponentModel.PropertyDescriptor property in System.ComponentModel.TypeDescriptor.GetProperties(this))
            {
                var value = property.GetValue(this);
                WritePropertyDesc(writer, property);
                if(value != null)
                {
                    if(typeof(XmlSettingsBase).IsAssignableFrom(value.GetType()))
                    {
                        var settings = (XmlSettingsBase)property.GetValue(this);
                        if((settings != null) && settings.SaveAsChild)
                        {
                            writer.WriteStartElement(property.Name);
                            settings.Save(writer);
                            writer.WriteEndElement();
                        }
                    } else if(!property.IsReadOnly)
                    {
                        writer.WriteElementString(property.Name, property.Converter.ConvertToString(value));
                    }
                }
                else
                {
                    WriteCommentedProperty(writer, property.Name);
                }
            }
        }
    }

    /// Custom class to allow string arrays to be read and written to/from settings
    class XmlStringArray : XmlSettingsBase, IEnumerable<string>
    {
        public XmlStringArray(IEnumerable<string> items, string name)
        {
            this._items = items;
            this._name = name;
            SetSaveAsChild(this, true);
        }

        string _name;
        IEnumerable<string> _items;

        protected override void Load(System.Xml.Linq.XElement xml)
        {
            var items = new List<string>();
            foreach(var item in xml.Elements(this._name))
            {
                items.Add(item.Value);
            }
            this._items = items;
            SetNeedsSave(this, false);
        }

        protected override void Save(System.Xml.XmlWriter writer)
        {
            if(this._items == null || !this._items.Any())
            {
                WriteCommentedProperty(writer, this._name);
                return;
            }

            foreach(var item in this._items)
            {
                writer.WriteElementString(this._name, item);
            }
        }

        public IEnumerator<string> GetEnumerator()
        {
            return this._items.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }

    /// This is the base class for the standard settings, the main settigns class should inherit from this
    /// one since it provides the methods to interact with the T4 system and EnvDTE. Sub-properties can
    /// just inherit from XmlSettingsBase.
    abstract class XmlSettings : XmlSettingsBase
    {
        protected static T Load<T>(ITextTemplatingEngineHost host) where T : XmlSettings, new()
        {
            T settings = new T();
            settings.Init(host);
            return settings;
        }

        void Init(ITextTemplatingEngineHost host)
        {

            this.TemplateFile = Path.GetFileName(host.TemplateFile);
            this.TemplateFolder = Path.GetDirectoryName(host.TemplateFile);

            // Get the DTE service from the host
            var serviceProvider = host as IServiceProvider;
            if (serviceProvider != null)
            {
                this.DTE = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
            }

            // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
            if (this.DTE == null)
            {
                throw new Exception("T4Build can only execute through the Visual Studio host");
            }

            this.ProjectItem = this.DTE.Solution.FindProjectItem(host.TemplateFile);

            // If the .tt file is not opened, open it
            if (this.ProjectItem.Document == null)
                this.ProjectItem.Open(EnvDTE.Constants.vsViewKindCode);

            this.Project = this.ProjectItem.ContainingProject;

            if (Project == null)
            {
                throw new Exception("Could not find the VS Project containing the T4 file.");
            }

            this.Load();
            this.Init();
        }

        public string TemplateFile { get; private set; }

        public string TemplateFolder { get; private set; }

        public DTE DTE { get; private set; }

        public ProjectItem ProjectItem { get; private set; }

        public Project Project { get; private set; }

        ProjectItem FindProjectItemRecursive(ProjectItems items, string name)
        {
            if(items == null)
                return null;

            foreach(ProjectItem item in items)
            {
                if(item.Name.Equals(name) || item.Name.StartsWith(name + "."))
                    return item;
                var found = FindProjectItemRecursive(item.ProjectItems, name);
                if(found != null)
                    return found;
            }

            return null;
        }

        protected ProjectItem FindProjectItem(string name)
        {
            return this.FindProjectItemRecursive(this.Project.ProjectItems, name);
        }

        protected string SettingsFile
        {
            get
            {
                return Path.Combine(this.TemplateFolder, string.Concat(this.TemplateFile, ".settings.xml"));
            }
        }

        void Load()
        {
            if(System.IO.File.Exists(this.SettingsFile))
                try
                {
                    this.Load(System.Xml.Linq.XElement.Load(this.SettingsFile));
                } catch { throw; }
        }

        public void SaveChanges(Manager manager)
        {
            // Avoid saving if we dont need to;
            if(!this.NeedsSave)
                return;

            if(manager.FileOkToWrite(this.SettingsFile))
            {
                var settings = new System.Xml.XmlWriterSettings
                    {
                        Indent = true
                        };
                using(var writer = System.Xml.XmlWriter.Create(this.SettingsFile, settings))
                {
                    writer.WriteStartDocument();
                    writer.WriteStartElement(this.GetType().Name);
                    this.Save(writer);
                    writer.WriteEndElement();
                    writer.WriteEndDocument();
                }

                var item = this.ProjectItem.Collection.AddFromFile(this.SettingsFile);
                item.Properties.Item("ItemType").Value = "None";
            } else
                TT.Error(string.Format("{0} cannot save settings file: {1}", T4FileName, this.SettingsFile));
        }
    }

/*
    End of T4MVC (MvcSettings): https://github.com/T4MVC
*/
/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/


// Manager class records the various blocks so it can split them up
    class Manager
    {
        private class Block
        {
            public String Name;
            public int Start, Length;
        }

        private Block currentBlock;
        private List<Block> files = new List<Block>();
        private Block footer = new Block();
        private Block header = new Block();
        private ITextTemplatingEngineHost host;
        private StringBuilder template;
        protected List<String> generatedFileNames = new List<String>();

        public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template)
        {
            return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
        }

        public virtual bool FileOkToWrite(String fileName)
        {
            return true;
        }

        public void KeepGeneratedFile(String name)
        {
            name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
            generatedFileNames.Add(name);
        }
    
        public void StartNewFile(String name)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            CurrentBlock = new Block { Name = name };
        }

        public void StartFooter()
        {
            CurrentBlock = footer;
        }

        public void StartHeader()
        {
            CurrentBlock = header;
        }

        public void EndBlock()
        {
            if (CurrentBlock == null)
                return;
            CurrentBlock.Length = template.Length - CurrentBlock.Start;
            if (CurrentBlock != header && CurrentBlock != footer)
                files.Add(CurrentBlock);
            currentBlock = null;
        }

        public virtual void Process(bool split)
        {
            if (split)
            {
                EndBlock();
                String headerText = template.ToString(header.Start, header.Length);
                String footerText = template.ToString(footer.Start, footer.Length);
                String outputPath = Path.GetDirectoryName(host.TemplateFile);
                files.Reverse();
                foreach (Block block in files)
                {
                    String fileName = Path.Combine(outputPath, block.Name);
                    String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                    generatedFileNames.Add(fileName);
                    CreateFile(fileName, content);
                    template.Remove(block.Start, block.Length);
                }
            }
        }

        protected virtual void CreateFile(String fileName, String content)
        {
            if (IsFileContentDifferent(fileName, content))
                File.WriteAllText(fileName, content);
        }

        public virtual String GetCustomToolNamespace(String fileName)
        {
            return null;
        }

        public virtual String DefaultProjectNamespace
        {
            get { return null; }
        }

        protected bool IsFileContentDifferent(String fileName, String newContent)
        {
            return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
        }

        private Manager(ITextTemplatingEngineHost host, StringBuilder template)
        {
            this.host = host;
            this.template = template;
        }

        private Block CurrentBlock
        {
            get { return currentBlock; }
            set
            {
                if (CurrentBlock != null)
                    EndBlock();
                if (value != null)
                    value.Start = template.Length;
                currentBlock = value;
            }
        }

        private class VSManager : Manager
        {
            private EnvDTE.ProjectItem templateProjectItem;
            private EnvDTE.DTE dte;
            private Action<String> checkOutAction;
            private Action<IEnumerable<String>> projectSyncAction;
            private IVsQueryEditQuerySave2 queryEditSave;

            public override String DefaultProjectNamespace
            {
                get
                {
                    return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
                }
            }

            public override String GetCustomToolNamespace(string fileName)
            {
                return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
            }

            public override void Process(bool split)
            {
                if (templateProjectItem.ProjectItems == null)
                    return;
                base.Process(split);
                projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
            }

            public override bool FileOkToWrite(String fileName)
            {
                CheckoutFileIfRequired(fileName);
                return base.FileOkToWrite(fileName);
            }

            protected override void CreateFile(String fileName, String content)
            {
                if (IsFileContentDifferent(fileName, content))
                {
                    CheckoutFileIfRequired(fileName);
                    File.WriteAllText(fileName, content);
                }
            }

            internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
                : base(host, template)
            {
                var hostServiceProvider = (IServiceProvider)host;
                if (hostServiceProvider == null)
                    throw new ArgumentNullException("Could not obtain IServiceProvider");
                dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
                if (dte == null)
                    throw new ArgumentNullException("Could not obtain DTE from host");
                templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
                checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
                projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
                queryEditSave = (IVsQueryEditQuerySave2)hostServiceProvider.GetService(typeof(SVsQueryEditQuerySave));
            }

            private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
            {
                var keepFileNameSet = new HashSet<String>(keepFileNames);
                var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
                var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
                foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                    projectFiles.Add(projectItem.get_FileNames(0), projectItem);

                // Remove unused items from the project
                foreach (var pair in projectFiles)
                    if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                        pair.Value.Delete();

                // Add missing files to the project
                foreach (String fileName in keepFileNameSet)
                    if (!projectFiles.ContainsKey(fileName))
                        templateProjectItem.ProjectItems.AddFromFile(fileName);
            }

            private void CheckoutFileIfRequired(String fileName)
            {
                if (queryEditSave != null)
                {
                    uint pfEditVerdict;
                    queryEditSave.QuerySaveFile(fileName, 0, null, out pfEditVerdict);
                }
                   else
                {
                    var sc = dte.SourceControl;
                    if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName)) 
                        checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
                }
            }
        }
    }

/*
    End of Manager.tt
*/
#>